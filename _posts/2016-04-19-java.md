---
layout: post
title: java -- Expo Basics(基础篇)
---
#### 目录
* [genericity (泛型)](#genericity) 
* [reflect (反射)](#reflect)
* [new 和 newInstance](#newAndnewInstance)
* [String、StringBuffer、StringBuilder](#String)

<h5 id="genericity">genericity（泛型）</h5> 
    
    1.基本类型介绍
    E - Element (在集合中使用，因为集合中存放的是元素)
    T - Type (Java 类)
    K - Key (键)
    V - Value （值）
    N - Number （数值类型）
    ？- 表示不确定的Java类型
        
<h5 id="reflect">reflect (反射) </h5> 
     
    
    Reflect类
    Field  : 属性 (getDeclaredField)
    Method : 方法 (getDeclaredMethod)
    Contructor : 构造函数 ()getDeclaredConstructor)
    
```
一个反射的例子：
    /**
     * 拷贝子类对象的属性值给父类对象
     * @param base 父类对象
     * @param derived 子类对象
     * @param <V>
     */
    static <V> void func(V base, V derived) throws Exception{
            Class cls1 = base.getClass();
            Class cls2 = derived.getClass();
            // 如果base不是derived的父类,则退出
            if (!cls1.isAssignableFrom(cls2)) {
                return;
            }
            Field[] fds = derived.getClass().getDeclaredFields();
            String methodNameSet="";
            String methodNameGet="";
            for (Field field : fds) {
                String str = field.getName();
                methodNameGet = "get" + str.substring(0, 1).toUpperCase() 
                + str.substring(1);
                
                /*调用derived对象 的get方法获取属性值*/
                Method methodGet = cls2.getDeclaredMethod(methodNameGet);
                String vlaue = (String) methodGet.invoke(derived); 
                
                /*调用base对象的 set方法设置属性值*/
                methodNameSet = "set" + str.substring(0, 1).toUpperCase() 
                + str.substring(1);
                Method method = cls1.getDeclaredMethod(methodNameSet, 
                                field.getType());
                method.invoke(derived, vlaue);
            }
    }
```

<h5 id="newAndnewInstance">new 和 newInstance </h5> 

```
    new : 使用构造函数实例化对象
    newInstance :使用类加载机实例化对象
```
    
<h5 id="String">String、StringBuffer、StringBuilder</h5> 

```
    简述：
    
    String : 字符串常量，
    StringBuffer : 字符串变量（线程安全）
    StringBuilder : 字符串变量（非线程安全）
    ------------------------------------
    1.String 和 StringBuffer
      性能差异：
      
      String s1 = "s1",s2 = "s2",s3 = "s3";    
      StringBuffer s = new StringBuffer();
      
      s1 = s2+s3;  /*相当于生成一个新的String存放s2+s3的结果，然后让s1指向他。*/
      s = s.append(s2).append(s3);  /*不生成新对象，因为StringBuffer是变长的 。*/
      
      综上，String 比 StringBuffer 一般情况下效率低。
      
    2.StringBuffer 和 StringBuilder
      性能差异：
      StringBuilder > StringBuffer
      线程安全：
      StringBuilder不保证同步，StringBuffer线程安全，保证同步.
```
   
